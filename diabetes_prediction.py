# -*- coding: utf-8 -*-
"""Diabetes Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19qzi6UDNkNg5sPEMJvQVen29WlUiP_E6
"""

# Import necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.metrics import classification_report, confusion_matrix, precision_score, recall_score, f1_score
import joblib

# Set style for plots
sns.set()

# Load the dataset
data = pd.read_csv('/content/diabetes prediction dataset.csv')

# Handle zero values (treat them as missing)
cols_with_zero = ['BMI', 'BloodPressure', 'Glucose', 'Insulin', 'SkinThickness']
for col in cols_with_zero:
    data[col] = data[col].replace(0, np.nan)
    data[col].fillna(data[col].mean(), inplace=True)

# Outlier removal
def remove_outliers(df, column, quantile):
    upper_limit = df[column].quantile(quantile)
    return df[df[column] < upper_limit]

data = remove_outliers(data, 'Pregnancies', 0.98)
data = remove_outliers(data, 'BMI', 0.99)
data = remove_outliers(data, 'SkinThickness', 0.99)
data = remove_outliers(data, 'Insulin', 0.95)
data = remove_outliers(data, 'DiabetesPedigreeFunction', 0.99)
data = remove_outliers(data, 'Age', 0.99)

# Features and labels
X = data.drop(columns=['Outcome'])
y = data['Outcome']

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=0)

# Standardize features
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Initialize models
knn_model = KNeighborsClassifier()
svm_model = SVC(probability=True)

# Cross-validation
knn_cv = cross_val_score(knn_model, X_train, y_train, cv=5, scoring='accuracy')
svm_cv = cross_val_score(svm_model, X_train, y_train, cv=5, scoring='accuracy')

# Fit models
knn_model.fit(X_train, y_train)
svm_model.fit(X_train, y_train)

# Predictions
knn_pred = knn_model.predict(X_test)
svm_pred = svm_model.predict(X_test)

# Reports
print("k-NN Classification Report:\n", classification_report(y_test, knn_pred))
print("SVM Classification Report:\n", classification_report(y_test, svm_pred))

# Confusion matrices
fig, axes = plt.subplots(1, 2, figsize=(12, 5))
sns.heatmap(confusion_matrix(y_test, knn_pred), annot=True, fmt='g', cmap='Blues', ax=axes[0])
axes[0].set_title('Confusion Matrix - k-NN')
axes[0].set_xlabel('Predicted'); axes[0].set_ylabel('True')

sns.heatmap(confusion_matrix(y_test, svm_pred), annot=True, fmt='g', cmap='Blues', ax=axes[1])
axes[1].set_title('Confusion Matrix - SVM')
axes[1].set_xlabel('Predicted'); axes[1].set_ylabel('True')

plt.tight_layout()
plt.show()

# Evaluation metrics for plotting
models = {'k-NN': knn_pred, 'SVM': svm_pred}
precision_scores = {}
recall_scores = {}
f1_scores = {}

for name, pred in models.items():
    precision_scores[name] = precision_score(y_test, pred)
    recall_scores[name] = recall_score(y_test, pred)
    f1_scores[name] = f1_score(y_test, pred)

# Plotting metrics
def plot_metric(metric_dict, metric_name):
    plt.figure(figsize=(8, 5))
    plt.bar(metric_dict.keys(), metric_dict.values(), color=['blue', 'green'])
    plt.title(f'{metric_name} Comparison')
    plt.ylabel(metric_name)
    plt.ylim(0, 1)
    plt.grid(axis='y')
    plt.show()

plot_metric(precision_scores, "Precision")
plot_metric(recall_scores, "Recall")
plot_metric(f1_scores, "F1-Score")

# Save models as .pkl
joblib.dump(knn_model, "knn_model.pkl")
joblib.dump(svm_model, "svm_model.pkl")
print("âœ… Models saved as knn_model.pkl and svm_model.pkl")

!pip install gradio

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import gradio as gr
# import numpy as np
# import joblib
# 
# # Load models
# knn_model = joblib.load("knn_model.pkl")
# svm_model = joblib.load("svm_model.pkl")
# 
# def predict(pregnancies, glucose, bp, skin, insulin, bmi, dpf, age, model_choice):
#     user_input = np.array([[pregnancies, glucose, bp, skin, insulin, bmi, dpf, age]])
#     model = knn_model if model_choice == "k-NN" else svm_model
#     pred = model.predict(user_input)[0]
#     return "Diabetic" if pred == 1 else "Non-Diabetic"
# 
# inputs = [
#     gr.Number(label="Pregnancies", value=0),
#     gr.Number(label="Glucose Level", value=0),
#     gr.Number(label="Blood Pressure", value=0),
#     gr.Number(label="Skin Thickness", value=0),
#     gr.Number(label="Insulin", value=0),
#     gr.Number(label="BMI", value=0.0),
#     gr.Number(label="Diabetes Pedigree Function", value=0.0),
#     gr.Number(label="Age", value=10),
#     gr.Radio(["k-NN", "SVM"], label="Choose Model")
# ]
# 
# output = gr.Textbox(label="Prediction")
# 
# demo = gr.Interface(fn=predict, inputs=inputs, outputs=output, title="Diabetes Prediction App")
# demo.launch(share=True)  # share=True creates a public URL automatically
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile requirements.txt
# gradio
# numpy
# scikit-learn
# joblib
#

!pip install huggingface_hub
from huggingface_hub import login
login()

!apt-get install git -y
!git config --global user.email "aalokhya@gmail.com"
!git config --global user.name "aalokhya"

!git clone https://huggingface.co/spaces/Aalokhya/Diabetes-Prediction

# Commented out IPython magic to ensure Python compatibility.
# %cd Diabetes-Prediction

!mv /content/app.py .
!mv /content/requirements.txt .
!mv /content/knn_model.pkl .
!mv /content/svm_model.pkl .

!git add app.py requirements.txt knn_model.pkl svm_model.pkl
!git commit -m "Add diabetes prediction app and model files"
!git push